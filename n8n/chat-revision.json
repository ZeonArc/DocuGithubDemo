{
  "name": "DocuGitHub - Chat Revision",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chat",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook - Chat",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [0, 300],
      "webhookId": "docugithub-chat"
    },
    {
      "parameters": {
        "jsCode": "// Validate HMAC signature\nconst crypto = require('crypto');\n\nconst webhookSecret = $env.WEBHOOK_SECRET;\nconst signature = $input.first().json.headers['x-webhook-signature'];\nconst body = $input.first().json.body;\n\nif (!webhookSecret) {\n  throw new Error('WEBHOOK_SECRET environment variable not configured');\n}\n\nif (!signature) {\n  return [{ json: { valid: false, error: 'Missing signature header' } }];\n}\n\nconst expectedSignature = crypto\n  .createHmac('sha256', webhookSecret)\n  .update(JSON.stringify(body))\n  .digest('hex');\n\nconst isValid = crypto.timingSafeEqual(\n  Buffer.from(signature),\n  Buffer.from('sha256=' + expectedSignature)\n);\n\nreturn [{ json: { valid: isValid, body: body } }];"
      },
      "id": "validate-hmac",
      "name": "Validate HMAC Signature",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "sig-valid",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              },
              "leftValue": "={{ $json.valid }}",
              "rightValue": ""
            }
          ]
        }
      },
      "id": "if-signature-valid",
      "name": "IF Signature Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [440, 300]
    },
    {
      "parameters": {
        "jsCode": "// Validate chat request\nconst body = $input.first().json.body;\nconst { session_id, message, current_readme, section_context } = body;\n\nconst errors = [];\n\nif (!session_id) {\n  errors.push('session_id is required');\n}\n\nif (!message || typeof message !== 'string' || message.trim().length === 0) {\n  errors.push('message is required and must be a non-empty string');\n}\n\nif (message && message.length > 10000) {\n  errors.push('message must be less than 10000 characters');\n}\n\nif (!current_readme || typeof current_readme !== 'string') {\n  errors.push('current_readme is required');\n}\n\nif (errors.length > 0) {\n  return [{ json: { valid: false, errors } }];\n}\n\nreturn [{ json: {\n  valid: true,\n  session_id,\n  message: message.trim(),\n  current_readme,\n  section_context: section_context || null\n} }];"
      },
      "id": "validate-request",
      "name": "Validate Chat Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "request-valid",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              },
              "leftValue": "={{ $json.valid }}",
              "rightValue": ""
            }
          ]
        }
      },
      "id": "if-request-valid",
      "name": "IF Request Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [880, 200]
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "sessions",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "keyValue": "={{ $json.session_id }}"
            }
          ]
        }
      },
      "id": "fetch-session",
      "name": "Fetch Session",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1100, 100],
      "credentials": {
        "supabaseApi": {
          "id": "{{ $credentials.supabase }}",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "session-exists",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              },
              "leftValue": "={{ $json.id }}",
              "rightValue": ""
            }
          ]
        }
      },
      "id": "if-session-exists",
      "name": "IF Session Exists",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [1320, 100]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "readme_versions",
        "returnAll": false,
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "session_id",
              "keyValue": "={{ $('IF Request Valid').first().json.session_id }}"
            }
          ]
        },
        "options": {
          "orderBy": {
            "orderBy": [
              {
                "field": "version",
                "direction": "desc"
              }
            ]
          }
        }
      },
      "id": "get-latest-version",
      "name": "Get Latest Version Number",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1540, 0],
      "credentials": {
        "supabaseApi": {
          "id": "{{ $credentials.supabase }}",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build chat revision prompt\nconst session = $('IF Session Exists').first().json;\nconst chatRequest = $('IF Request Valid').first().json;\nconst latestVersion = $input.first().json;\n\n// Parse session data\nconst analysis = typeof session.analysis === 'string' ? JSON.parse(session.analysis) : (session.analysis || {});\nconst preferences = typeof session.preferences === 'string' ? JSON.parse(session.preferences) : (session.preferences || {});\n\nconst currentVersion = latestVersion?.version || 0;\nconst newVersion = currentVersion + 1;\n\nconst prompt = `You are an AI assistant helping to revise a README.md file based on user feedback.\n\n## Repository Context\n- **Repository:** ${session.repo_owner}/${session.repo_name}\n- **Project Purpose:** ${analysis.project_purpose || 'See analysis below'}\n- **Tech Stack:** ${JSON.stringify(analysis.tech_stack || {})}\n\n## User Preferences\n- **Tone:** ${preferences.tone || 'professional'}\n- **Emoji Style:** ${preferences.emoji_style || 'minimal'}\n\n## Current README (Version ${currentVersion}):\n\\`\\`\\`markdown\n${chatRequest.current_readme}\n\\`\\`\\`\n\n${chatRequest.section_context ? `## Section Context\\nThe user is specifically referring to this section: ${chatRequest.section_context}\\n` : ''}\n\n## User's Revision Request:\n\"${chatRequest.message}\"\n\n## Instructions:\n\n1. Carefully analyze the user's request and understand what changes they want.\n\n2. Make the requested changes to the README while:\n   - Maintaining consistency with the existing style and tone\n   - Preserving sections the user didn't mention\n   - Keeping proper markdown formatting\n   - Following the user's preferences (tone: ${preferences.tone || 'professional'}, emoji: ${preferences.emoji_style || 'minimal'})\n\n3. After making changes, provide:\n   - The COMPLETE updated README (not just the changed sections)\n   - A brief summary of changes made\n\n## Response Format:\nRespond with a JSON object containing exactly these fields:\n{\n  \"revised_readme\": \"<complete updated README markdown>\",\n  \"changes_summary\": \"<brief bullet-point summary of changes made>\",\n  \"sections_modified\": [\"<list of section names that were modified>\"]\n}\n\nRespond with ONLY the JSON object, no additional text.`;\n\nreturn [{ json: {\n  session_id: chatRequest.session_id,\n  owner: session.repo_owner,\n  repo: session.repo_name,\n  message: chatRequest.message,\n  current_readme: chatRequest.current_readme,\n  current_version: currentVersion,\n  new_version: newVersion,\n  prompt\n} }];"
      },
      "id": "build-revision-prompt",
      "name": "Build Revision Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 0]
    },
    {
      "parameters": {
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify($json.prompt) }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 0.5,\n    \"topK\": 40,\n    \"topP\": 0.95,\n    \"maxOutputTokens\": 16384,\n    \"responseMimeType\": \"application/json\"\n  },\n  \"safetySettings\": [\n    {\"category\": \"HARM_CATEGORY_HARASSMENT\", \"threshold\": \"BLOCK_NONE\"},\n    {\"category\": \"HARM_CATEGORY_HATE_SPEECH\", \"threshold\": \"BLOCK_NONE\"},\n    {\"category\": \"HARM_CATEGORY_SEXUALLY_EXPLICIT\", \"threshold\": \"BLOCK_NONE\"},\n    {\"category\": \"HARM_CATEGORY_DANGEROUS_CONTENT\", \"threshold\": \"BLOCK_NONE\"}\n  ]\n}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true,
              "neverError": true
            }
          },
          "timeout": 120000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "retryInterval": 5000,
            "retryIntervalMultiplier": 2
          }
        }
      },
      "id": "call-gemini",
      "name": "Generate Revision with Gemini",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [1980, 0],
      "credentials": {
        "httpQueryAuth": {
          "id": "{{ $credentials.geminiApiKey }}",
          "name": "Gemini API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process Gemini response\nconst response = $input.first().json;\nconst prevData = $('Build Revision Prompt').first().json;\n\nif (response.statusCode === 429 || (response.body?.error?.status === 'RESOURCE_EXHAUSTED')) {\n  throw new Error('Gemini API rate limit exceeded. Please try again later.');\n}\n\nif (response.statusCode !== 200) {\n  throw new Error(`Gemini API error: ${response.statusCode} - ${JSON.stringify(response.body)}`);\n}\n\nconst geminiContent = response.body?.candidates?.[0]?.content?.parts?.[0]?.text;\n\nif (!geminiContent) {\n  throw new Error('No content in Gemini response');\n}\n\n// Parse the JSON response\nlet revisionResult;\ntry {\n  revisionResult = JSON.parse(geminiContent);\n} catch (e) {\n  // Try to extract JSON from markdown code blocks\n  const jsonMatch = geminiContent.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (jsonMatch) {\n    revisionResult = JSON.parse(jsonMatch[1]);\n  } else {\n    throw new Error('Failed to parse Gemini response as JSON: ' + e.message);\n  }\n}\n\nif (!revisionResult.revised_readme) {\n  throw new Error('Invalid response format: missing revised_readme');\n}\n\n// Clean up the revised README\nlet revisedReadme = revisionResult.revised_readme.trim();\nif (revisedReadme.startsWith('```markdown')) {\n  revisedReadme = revisedReadme.slice(11);\n}\nif (revisedReadme.startsWith('```md')) {\n  revisedReadme = revisedReadme.slice(5);\n}\nif (revisedReadme.startsWith('```')) {\n  revisedReadme = revisedReadme.slice(3);\n}\nif (revisedReadme.endsWith('```')) {\n  revisedReadme = revisedReadme.slice(0, -3);\n}\nrevisedReadme = revisedReadme.trim();\n\nreturn [{ json: {\n  session_id: prevData.session_id,\n  owner: prevData.owner,\n  repo: prevData.repo,\n  revised_readme: revisedReadme,\n  changes_summary: revisionResult.changes_summary || 'Changes applied as requested',\n  sections_modified: revisionResult.sections_modified || [],\n  version: prevData.new_version,\n  user_message: prevData.message\n} }];"
      },
      "id": "process-revision-response",
      "name": "Process Revision Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 0]
    },
    {
      "parameters": {
        "operation": "create",
        "tableId": "readme_versions",
        "dataToSend": "defineBelow",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldName": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldName": "version",
              "fieldValue": "={{ $json.version }}"
            },
            {
              "fieldName": "content",
              "fieldValue": "={{ $json.revised_readme }}"
            },
            {
              "fieldName": "changes_summary",
              "fieldValue": "={{ $json.changes_summary }}"
            },
            {
              "fieldName": "user_message",
              "fieldValue": "={{ $json.user_message }}"
            },
            {
              "fieldName": "created_at",
              "fieldValue": "={{ new Date().toISOString() }}"
            }
          ]
        }
      },
      "id": "create-new-version",
      "name": "Create New README Version",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2420, 0],
      "credentials": {
        "supabaseApi": {
          "id": "{{ $credentials.supabase }}",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "sessions",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "keyValue": "={{ $('Process Revision Response').first().json.session_id }}"
            }
          ]
        },
        "dataToSend": "defineBelow",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldName": "current_version",
              "fieldValue": "={{ $('Process Revision Response').first().json.version }}"
            },
            {
              "fieldName": "status",
              "fieldValue": "revised"
            },
            {
              "fieldName": "updated_at",
              "fieldValue": "={{ new Date().toISOString() }}"
            }
          ]
        }
      },
      "id": "update-session-version",
      "name": "Update Session Version",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2640, 0],
      "credentials": {
        "supabaseApi": {
          "id": "{{ $credentials.supabase }}",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, session_id: $('Process Revision Response').first().json.session_id, revised_readme: $('Process Revision Response').first().json.revised_readme, version: $('Process Revision Response').first().json.version, changes_summary: $('Process Revision Response').first().json.changes_summary, sections_modified: $('Process Revision Response').first().json.sections_modified }) }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [2860, 0]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ error: true, code: 'INVALID_SIGNATURE', message: 'Invalid or missing webhook signature' }) }}",
        "options": {
          "responseCode": 401,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-invalid-signature",
      "name": "Respond - Invalid Signature",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [660, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ error: true, code: 'INVALID_REQUEST', message: 'Invalid request', errors: $json.errors }) }}",
        "options": {
          "responseCode": 400,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-invalid-request",
      "name": "Respond - Invalid Request",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ error: true, code: 'SESSION_NOT_FOUND', message: 'Session not found' }) }}",
        "options": {
          "responseCode": 404,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-session-not-found",
      "name": "Respond - Session Not Found",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [1540, 200]
    },
    {
      "parameters": {
        "content": "## DocuGitHub - Chat Revision Workflow\n\n**Endpoint:** POST /webhook/chat\n\n**Input:**\n```json\n{\n  \"session_id\": \"uuid\",\n  \"message\": \"Please add a Docker section\",\n  \"current_readme\": \"# Project...\\n...\",\n  \"section_context\": \"optional - specific section\"\n}\n```\n\n**Flow:**\n1. Validate HMAC signature\n2. Validate chat request\n3. Fetch session & latest version\n4. Build revision prompt with context\n5. Generate revision with Gemini\n6. Create new version in readme_versions\n7. Update session current_version\n8. Return revised README with change summary\n\n**Output:**\n```json\n{\n  \"success\": true,\n  \"revised_readme\": \"# Project...\\n...\",\n  \"version\": 2,\n  \"changes_summary\": \"Added Docker section...\",\n  \"sections_modified\": [\"deployment\"]\n}\n```",
        "height": 520,
        "width": 360
      },
      "id": "sticky-note",
      "name": "Workflow Documentation",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-320, 20]
    }
  ],
  "connections": {
    "Webhook - Chat": {
      "main": [
        [
          {
            "node": "Validate HMAC Signature",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate HMAC Signature": {
      "main": [
        [
          {
            "node": "IF Signature Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Signature Valid": {
      "main": [
        [
          {
            "node": "Validate Chat Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond - Invalid Signature",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Chat Request": {
      "main": [
        [
          {
            "node": "IF Request Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Request Valid": {
      "main": [
        [
          {
            "node": "Fetch Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond - Invalid Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session": {
      "main": [
        [
          {
            "node": "IF Session Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Session Exists": {
      "main": [
        [
          {
            "node": "Get Latest Version Number",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond - Session Not Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Latest Version Number": {
      "main": [
        [
          {
            "node": "Build Revision Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Revision Prompt": {
      "main": [
        [
          {
            "node": "Generate Revision with Gemini",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Revision with Gemini": {
      "main": [
        [
          {
            "node": "Process Revision Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Revision Response": {
      "main": [
        [
          {
            "node": "Create New README Version",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New README Version": {
      "main": [
        [
          {
            "node": "Update Session Version",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Session Version": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "DocuGitHub"
    }
  ],
  "triggerCount": 1,
  "pinData": {}
}
